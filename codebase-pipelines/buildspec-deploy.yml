version: 0.2

env:
  variables:
    DEPLOY_TIMEOUT: 1800
  parameter-store:
    SLACK_TOKEN: /codebuild/slack_oauth_token

phases:
  install:
    commands:
      - echo "Starting deployment script for ${SERVICE} service"
      - pip install yq --quiet
      - echo "Installing platform-helper"
      - pip install dbt-platform-helper --quiet
      - platform-helper --version 
      - echo "Installing regclient"
      - curl -s -L https://github.com/regclient/regclient/releases/latest/download/regctl-linux-amd64 > /usr/local/bin/regctl
      - chmod +x /usr/local/bin/regctl

  build:
    commands:
      - set -e

      # Extract timestamp from image config and check if it exists
      - aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

      - |
        SLACK_REF=$(regctl image config "${REPOSITORY_URL}:${IMAGE_TAG}" | jq -r '.config.Labels."uk.gov.trade.digital.build.timestamp"')
        if [ "$SLACK_REF" = "null" ] || [ -z "$SLACK_REF" ]; then
          echo "Image contains no timestamp label"
          exit 1
        fi
        echo "Found image timestamp $SLACK_REF"
        
      - UPPERCASE_SERVICE=$(echo "${SERVICE}" | tr '[:lower:]' '[:upper:]')
      - |
        MESSAGE=":rocket: STARTED -- Deployment for ${UPPERCASE_SERVICE} service"

      - platform-helper notify add-comment "${SLACK_CHANNEL_ID}" "${SLACK_TOKEN}" "${SLACK_REF}" "${MESSAGE}"

      # Check if the specified image tag exists
      - |
        if ! aws ecr describe-images --repository-name "${REPOSITORY_NAME}" --image-ids "imageTag=${IMAGE_TAG}" > /dev/null 2>&1; then
          echo "Error: image tag ${IMAGE_TAG} not found in repository ${REPOSITORY_NAME}"
          exit 1
        fi

      # Check environment exists in config
      - |
        if [ $(echo $ENV_CONFIG | jq 'has('\"${ENVIRONMENT}\"')') == "false" ]; then
          echo "Error: environment ${ENVIRONMENT} not listed in environment config"
          exit 1
        fi

      - task_family="${APPLICATION}-${ENVIRONMENT}-${SERVICE}"
      - cluster="${APPLICATION}-${ENVIRONMENT}"
      - image_uri="${REPOSITORY_URL}:${IMAGE_TAG}"

      # Assume environment role
      - account_id=$(echo ${ENV_CONFIG} | jq -c -r .${ENVIRONMENT}.account)
      - assumed_role=$(aws sts assume-role --role-arn "arn:aws:iam::${account_id}:role/${APPLICATION}-${ENVIRONMENT}-codebase-pipeline-deploy" --role-session-name "${ENVIRONMENT}-codebase-pipeline-deploy")
      - export AWS_ACCESS_KEY_ID=$(echo $assumed_role | jq -r .Credentials.AccessKeyId)
      - export AWS_SECRET_ACCESS_KEY=$(echo $assumed_role | jq -r .Credentials.SecretAccessKey)
      - export AWS_SESSION_TOKEN=$(echo $assumed_role | jq -r .Credentials.SessionToken)

      # Get service name
      - service_name=$(aws ecs list-services --cluster "${cluster}" | jq -r '.serviceArns[] | select(contains("'${cluster}'-'${SERVICE}'-Service"))' | cut -d '/' -f3)

      # Update task definition
      - task_definition=$(aws ecs describe-task-definition --task-definition "${task_family}")
      - new_task_definition=$(echo ${task_definition} | jq '.taskDefinition | .containerDefinitions |= map(if .name == '\"${SERVICE}\"' then .image = '\"${image_uri}\"' else . end) | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) |  del(.registeredAt)  | del(.registeredBy)')
      - new_task_info=$(aws ecs register-task-definition --cli-input-json "${new_task_definition}")
      - new_revision=$(echo ${new_task_info} | jq '.taskDefinition.revision')

      # Get desired task count
      - count=0
      - cd "${CODEBUILD_SRC_DIR}"

      # If count is a range, get the first value otherwise get count
      - |
        if [ $(yq '.count | type == "object"' copilot/web/manifest.yml) == "true" ]; then
          count=$(yq '.count.range' copilot/web/manifest.yml | tr -d '"' | cut -d '-' -f1)
        else
          count=$(yq '.count' copilot/web/manifest.yml)
        fi

      # Check for environment overrides
      - |
        if [ $(yq '.environments.'${ENVIRONMENT}'.count | type == "object"' copilot/web/manifest.yml) == "true" ]; then
          env_count=$(yq '.environments.'${ENVIRONMENT}'.count.range' copilot/web/manifest.yml | tr -d '"' | cut -d '-' -f1)
        else
          env_count=$(yq '.environments.'${ENVIRONMENT}'.count' copilot/web/manifest.yml)
        fi

      - |
        if [[ "${env_count}" != "null" ]]; then
          count=${env_count}
        fi

      # Start deployment
      - |
        BUILD_ID_PREFIX=$(echo $CODEBUILD_BUILD_ID | cut -d':' -f1)
        echo "BUILD_ID_PREFIX - ${BUILD_ID_PREFIX}"

      - |
        MESSAGE=":building_construction: Deploying ${UPPERCASE_SERVICE} service  -  Build number logs: <https://${AWS_REGION}.console.aws.amazon.com/codesuite/codebuild/${AWS_ACCOUNT_ID}/projects/${BUILD_ID_PREFIX}/build/${CODEBUILD_BUILD_ID}/?region=${AWS_REGION}|${CODEBUILD_BUILD_NUMBER}>"

      - platform-helper notify add-comment "${SLACK_CHANNEL_ID}" "${SLACK_TOKEN}" "${SLACK_REF}" "${MESSAGE}"

      - echo "Deploying ${image_uri} to ${service_name} in ${cluster} with task count ${count}"
      - start=$( date +%s )
      - deploy_status="IN_PROGRESS"
      - aws ecs update-service --cluster "${cluster}" --service "${service_name}" --task-definition "${task_family}:${new_revision}" --desired-count ${count} > /dev/null 2>&1

      # Check deployment status
      - |
        while [[ "${deploy_status}" == "IN_PROGRESS" || "${deploy_status}" == "PENDING" || "${deploy_status}" == "ROLLBACK_IN_PROGRESS" ]];
        do
          sleep 10
          now=$( date +%s )
          elapsed=$(( now-start ))

          deploy_status=$(aws ecs list-service-deployments --cluster "${cluster}" --service "${service_name}" --created-at "after=${start}" | jq -r '.serviceDeployments[0].status')
          echo "Deployment status after ${elapsed} seconds: ${deploy_status}"

          if [[ ${elapsed} -gt ${DEPLOY_TIMEOUT} ]]; then
            echo "Error: deployment not completed in ${DEPLOY_TIMEOUT} seconds"
            exit 1
          fi
        done
        
      # Check deployment success
      - |
        case "${deploy_status}" in
          SUCCESSFUL)
            STATUS=":large_green_circle:"
            ;;
          ROLLBACK_SUCCESSFUL)
            STATUS=":large_orange_circle::white_check_mark:"
            ;;
          ROLLBACK_IN_PROGRESS)
            STATUS=":large_orange_circle::hourglass:"
            ;;
          ROLLBACK_FAILED)
            STATUS=":large_orange_circle::arrow_right::red_circle:"
            ;;
          *)
            STATUS=":large_blue_circle:"
            ;;
        esac
        echo "Status emoji set to ${STATUS}"
      
      - |
        MESSAGE="${STATUS} Deployment of ${image_uri} to ${service_name} is: ${deploy_status}"

      - platform-helper notify add-comment "${SLACK_CHANNEL_ID}" "${SLACK_TOKEN}" "${SLACK_REF}" "${MESSAGE}"
      
      # Exit with an error code if deployment did not succeed 
      - | 
        if [ "${deploy_status}" != "SUCCESSFUL" ]; then 
          echo "Error: deployment status is ${deploy_status}" 
          exit 1 
        fi
